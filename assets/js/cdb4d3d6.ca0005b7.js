"use strict";(self.webpackChunklittle_sandman=self.webpackChunklittle_sandman||[]).push([[105],{2929:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"music","metadata":{"permalink":"/dreamland-ZiaLai/blog/music","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-05-27-multitrack-music.md","source":"@site/blog/2025-05-27-multitrack-music.md","title":"\ud83c\udfbb Musique multipiste","description":"Bonjour \xe0 tous !","date":"2025-05-27T00:00:00.000Z","tags":[{"inline":true,"label":"musique","permalink":"/dreamland-ZiaLai/blog/tags/musique"}],"readingTime":2.64,"hasTruncateMarker":false,"authors":[{"name":"Bj\xf6rn LAI","socials":{},"key":null,"page":null}],"frontMatter":{"slug":"music","title":"\ud83c\udfbb Musique multipiste","authors":[{"name":"Bj\xf6rn LAI"}],"tags":["musique"]},"unlisted":false},"content":"Bonjour \xe0 tous !\\r\\n\\r\\nDans cet article, nous expliquerons comment nous avons r\xe9alis\xe9 la musique du premier niveau du jeu,\\r\\nainsi que les probl\xe8mes rencontr\xe9s au cours de cette \xe9tape.\\r\\n\\r\\nLa particularit\xe9 de cette musique est qu\'elle commence avec peu d\'instruments (le piano et le clavecin),\\r\\net d\'autres s\'ajoutent au fur et \xe0 mesure qu\'on progresse afin de cr\xe9er un effet de tension.\\r\\n\\r\\n\\r\\n## \ud83c\udfb6 Composition avec MuseScore\\r\\n\\r\\nLa musique a \xe9t\xe9 r\xe9alis\xe9e \xe0 l\'aide de MuseScore, un logiciel gratuit permettant de composer des morceaux en utilisant la \\r\\nnotation musicale standard, sur une partition.\\r\\n\\r\\n![musescore image](/img/musescore.png)\\r\\n\\r\\nL\'utilisation de ce logiciel est tr\xe8s pratique, car elle offre de nombreuses options d\'exports,\\r\\net notamment celle qui nous int\xe9resse : exporter les pistes s\xe9par\xe9ment.\\r\\n\\r\\nCependant, un autre probl\xe8me nous attend...\\r\\n\\r\\n## \u267e\ufe0f Probl\xe8me de loop\\r\\n\\r\\nEn g\xe9n\xe9ral, dans les jeux-vid\xe9os, la musique doit pouvoir tourner en boucle sans transition brusque,\\r\\net sans blanc \xe0 la fin. Et c\'est ce qu\'on souhaite pour notre musique.\\r\\n\\r\\nCependant, une particularit\xe9 de MuseScore est que lorsqu\'on exporte une musique, un blanc est rajout\xe9 \xe0 la fin pour permettre\\r\\naux derni\xe8res notes de r\xe9sonner jusqu\'\xe0 leur \xe9vanouissement complet, et il n\'existe aucune option pour emp\xeacher cela.\\r\\n\\r\\nApr\xe8s l\'export, on obtient sept fichiers audio au format ogg, un pour chaque instrument, mais comme ils ont chacun\\r\\nun blanc \xe0 la fin, la boucle musicale ne peut malheureusement pas poursuivre de fa\xe7on fluide.\\r\\n\\r\\nIl faut trouver un moyen de garantir une boucle parfaite !\\r\\n\\r\\n## \ud83d\udcbf Raccourcissement avec un script python\\r\\n\\r\\nNotre objectif est de couper la fin de chaque piste, en supprimant tout le temps \xe9coul\xe9 apr\xe8s la mesure finale. \\r\\n\\r\\nOn peut faire cela en utilisant n\'importe quel \xe9diteur audio, comme Audacity.\\r\\n\\r\\nToutefois, le nombre de pistes \xe9tant relativement\\r\\n\xe9lev\xe9, cela peut s\'av\xe9rer fastidieux. Et de plus, un d\xe9coupage manuel peut entrainer des impr\xe9cisions, ce qui entrainerait \\r\\nune terrible d\xe9synchronisation des pistes apr\xe8s quelques tours de boucle.\\r\\n\\r\\nIl devient donc particuli\xe8rement int\xe9ressant d\'automatiser ce processus.\\r\\n\\r\\nPour ce faire, nous avons utilis\xe9 un script python utilisant le module de traitement audio _pydub_.\\r\\nCela a permis d\'automatiser efficacement le d\xe9coupage des pistes, en garantissant une pr\xe9cision \xe0 la milliseconde pr\xe8s !\\r\\n\\r\\n\\r\\n## \ud83d\udd0a Chargement des sons dans Babylon.js\\r\\n\\r\\nIl ne reste plus qu\'\xe0 importer les sons dans Babylon. Mais prudence, il reste un dernier pi\xe8ge \xe0 \xe9viter.\\r\\n\\r\\nSi on charge successivement toutes les pistes, puis, qu\'on essaie imm\xe9diatement de les jouer, on peut obtenir le probl\xe8me suivant : \\r\\naucun son ne joue, car le chargement des sons n\'est pas encore termin\xe9 et est toujours en train de continuer de mani\xe8re asynchrone.\\r\\n\\r\\nPour \xe9viter cela, on utilise le param\xe8tre optionnel _readyToPlayCallback_ qui appellera une fonction \xe0 chaque fois qu\'un son finit de charger.\\r\\nCette derni\xe8re fonction a simplement pour effet d\'incr\xe9menter un compteur et de d\xe9marrer simultan\xe9ment tous les sons, si le quota de sons \xe0 charger est atteint.\\r\\n\\r\\nCe proc\xe9d\xe9 est d\xe9montr\xe9 dans ce [playground](https://playground.babylonjs.com/#PCY1J#6) de la doc de Babylon.js.\\r\\n\\r\\nEt voil\xe0 ! Une fois que tous les sons sont d\xe9marr\xe9s en m\xeame temps, on n\'a plus qu\'\xe0 couper le son des pistes qui ne doivent pas encore jouer, \\r\\net \xe0 les r\xe9activer petit \xe0 petit d\xe8s que le joueur atteint un objectif dans le niveau."}]}}')}}]);